## lock lab

### 实现

这是目前我遇到的最难的实验！锁的使用真是需要考虑很多情况。

第一个kalloc很简单，按照提示要求实现即可。

第二个是真难。使用哈希桶来保存buf，降低冲突。在这里，锁的粒度和保护对象的范围很难把握；为了避免死锁要适当解锁，还要时刻注意释放锁后的窗口期。

做的时候要注意以下几点：

1. 确保bcache中**至多只有一个**物理块的缓存！否则可能导致`panic: freeing free block`
2. 时刻谨记，释放锁后，保护的对象不再可靠。如果一个原子操作不得不要被拆成两个，一定要在第二个操作中检查对象的一致性是否还存在。


按照题目要求，建立一个哈希表，我使用的是链式哈希表。

给每个桶设置一个锁。用于保护桶内的buf的一些meta数据。在初始化时，先把所有buf都塞进0号桶中。然后对buf的修改和读取，都要先acquire桶的锁。

一开始，我很疑惑，定位buf所在的桶之前，要先访问buf的blockno；而如果不先获得buf所在桶的锁，访问buf的blockno似乎是不可靠的。例如brelse、bunpin、bin这类需要修改buf的引用计数的函数。处理不好很容易造成大量锁的竞争，可能还不如一个大锁。

后来发现，唯一对blockno修改情况只在bget中选择引用数为0的buf替换时发生；而一个buf一定正在被引用，才可能在brelse、bunpin、bin中出现，因此在这里blockno是安全的，无需锁的保护。

因此主要问题就是bget，它负责了对哈希表的维护。


它实现以下几步：

1. 查找blockno对应的桶（称为key桶）中是否有已经cache了的buf，如果有就acquiresleep它并返回。（**检查**）

2. 否则，遍历桶，找到时间戳最小的且引用次数为0，先将其从原来的桶逐出（evict）（**驱逐**）

3. 更新找到的buf，再放入key桶中。（**更新**）

第1步**检查**，如果找不到，别急着释放key桶的锁。指不定另一个进程这时也bget了同一个blockno，这边一释放，它就进来，然后也找不到。这样两个进程就同时进入了驱逐和更新的阶段，而这样必将导致创建两个buf，指向同一个物理块。驱逐和更新操作从开始都结束是一个原子操作，整个过程必须保证**blockno不存在**，因此全程要持有blockno对应的桶的锁。

第2步**驱逐**，这里要求时间戳最小，因此得遍历每个桶中所有buf；因为要保证**引用次数为0的一致性**，因此除了要对当前查看的桶加锁，还得对手中的候选buf对应的桶上锁，这里有可能会同时持有2个锁。在候选buf被更新之前，都不能释放掉它对应桶的锁，否则buf的引用次数随时可能被改（例如另一个进程调用bget）。最后得到想要的buf，将它从对应的桶中拿出，然后才可以释放桶的锁。此时buf自由啦，它不属于任何桶，不会被访问，可以被随意修改。

第3步**更新**，最后修改buf，然后放入key桶。此时才能释放key桶的锁。


但是上面有一个严重问题，就是会导致死锁！在驱逐过程中，可能同时持有两个锁，但是持有锁的顺序是固定的，第一次持有的锁一定比第二次持有锁靠前。只要有了顺序，就不会死锁；但是key桶的顺序是不确定的，取决于blockno，可能和其它进程造成回环死锁。

因此，不得已，在检查找不到时释放key桶的锁。为了保证驱逐和更新的原子性，使用一个大锁将它们保护起来。这时由于前面释放了锁，blockno不存在已经不可靠了，因此在进入驱逐和更新之前一定要再次进行一次检查操作，否则可能导致`panic: freeing free block`！到这里才算是完全完成了。

还有别的实现方法，我看到网上其它做法就是每个桶都是一个完整的bcache，所有blockno同余的buf都只在各种的桶中操作（检查更新驱逐都在同一个桶）。实现起来非常简单，性能也非常好，就是空间利用率太低了。


### 注意事项

make grade有时间限制，如果发现出现qemu-system-riscv64: terminating on signal 15 from pid XXXX (make)，可能是测试超时导致，换台更快的电脑试试吧！（我用云服务器跑总跑不满分，还找了半天虚空bug）

### 总结

sleeplock用于保护buf的data数据，因为涉及磁盘操作往往很久，使用sleeplock可以让出cpu；

spinlock用于保护buf的meta数据，因为这只涉及到内存访问修改，往往非常快。spinlock更合适。使用sleeplock的话切换开销会很大。

参考了一个文章，写的很好：https://juejin.cn/post/7021218568226209828
